/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package assignment_1;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.*;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.*;
import java.util.*;
import java.lang.reflect.Array;

public class SqlRunnerAPI implements SqlRunner {

    private final Connection connection;
    private final Document document;

    /**
     * A parameterized Constructor for the class.
     *
     * @param xmlFilePath Stores the path of the XML file which contains all the MySQL queries.
     * @param dbURL       Stores the path of the MySQL database.
     * @param username    Stores the username for the MySQL database.
     * @param password    Stores the password for the MySQL database.
     */
    public SqlRunnerAPI(String xmlFilePath, String dbURL, String username, String password) throws SQLException, ParserConfigurationException, IOException, SAXException {
        /*Setting up the required connections*/
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        connection = DriverManager.getConnection(dbURL, username, password);
        DocumentBuilder builder = factory.newDocumentBuilder();
        document = builder.parse(new File(xmlFilePath));
        document.getDocumentElement().normalize();
    }

    /**
     * Function to close the database connection.
     */
    public void close() throws SQLException {
        /*Closing the database connection*/
        connection.close();
    }

    /**
     * Parses the XML file to extract the value of the attribute 'paramType' and query string
     * using the queryId(unique) for the purpose.
     *
     * @param queryId Stores the path of the XML file which contains all the MySQL queries.
     * @return A 2-element list of strings, where the first element is the value of the attribute 'paramType'
     * and the second element is the query string.
     */
    private List<String> xmlParser(String queryId) throws XPathExpressionException {
        /*Searching the required sql node with the id queryId*/
        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xPath = xPathFactory.newXPath();

        String reqPath = "//sql[@id=\"" + queryId + "\"]";
        XPathExpression xPathExpression = xPath.compile(reqPath);
        NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);

        if (nodeList != null && nodeList.getLength() > 0) {
            /*Every SQL query has a unique ID in the XML file, hence the nodeList will contain at most one element.*/
            Element reqSqlNode = (Element) nodeList.item(0);
            /* Obtaining the value of the attribute paramType from the sql node*/
            String paramType = reqSqlNode.getAttribute("paramType").trim();
            String queryString = reqSqlNode.getTextContent().trim();

            /*Creating an ArrayList with the first element as the value of the paramType attribute and the second element
             as the query string*/
            List<String> finalList = new ArrayList<>();
            finalList.add(paramType);
            finalList.add(queryString);
            return finalList;
        } else {
            return null;
        }
    }

    /**
     * Function to check whether the string paramType matches any of the strings for primitive types.
     *
     * @param paramType Stores the string to be matched against the strings for primitive types.
     * @return Returns true if paramType matches with any of the strings representing primitive types, otherwise returns false.
     */
    private boolean isPrimitive(String paramType) {
        return switch (paramType) {
            case "java.lang.Byte", "java.lang.Short", "java.lang.Integer", "java.lang.Long", "java.lang.Float", "java.lang.Double", "java.lang.Boolean", "java.lang.Character", "java.lang.String" -> true;
            default -> false;
        };
    }

    /**
     * Function to check whether the string paramType matches any of the strings for the collections of a primitive type.
     *
     * @param paramType Stores the string to be matched against the strings for the collections of a primitive type.
     * @return Returns true if paramType matches with any of the strings representing the collections fo a primitive type,
     * otherwise returns false.
     */
    private boolean isCollectionOfPrimitives(String paramType) {
        return switch (paramType) {
            case "[B", "[S", "[I", "[J", "[F", "[D", "[Z", "[C", "[Ljava.lang.String;" -> true;
            default -> false;
        };
    }

    /**
     * Helper function to replace the placeholders in queryString with the String replaceStr.
     *
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param replaceStr Stores the string which should be used to replace the placeholders in queryString.
     * @return Returns the refined string after replacing the placeholders with the String replaceStr.
     */
    private String produceRefinedString(String queryString, String replaceStr) {
        StringBuilder refinedString = new StringBuilder();
        while (true) {
            /*Searching for the first occurrence of the start of the placeholder indicator "${"*/
            int startIndex = queryString.indexOf("${");
            if (startIndex != -1) {
                /*Searching for the first occurrence of the end of the placeholder indicator "}"*/
                int endIndex = queryString.indexOf("}");
                /*Substituting the placeholder with the replaceStr string*/
                refinedString.append(queryString, 0, startIndex).append(replaceStr);
                queryString = queryString.substring(endIndex + 1);
            } else {
                refinedString.append(queryString);
                break;
            }
        }
        return refinedString.toString();
    }

    /**
     * Function to replace the placeholders in the MySQL query string with appropriate values, when the queryParam is of primitive type.
     *
     * @param paramType   Value of the XML attribute 'paramType', which also represents the type of the queryType parameter.
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param queryParam  Stores the required values to replace the placeholders in the queryString argument.
     * @return Returns the MySQL query-string after replacing the placeholders with appropriate values.
     */
    private <T> String handlePrimitives(String paramType, String queryString, T queryParam) {
        String replaceStr;
        /*Checking whether the paramType is of a String.*/
        if (paramType.equals("java.lang.String"))
            replaceStr = "'" + queryParam.toString() + "'";
        else
            replaceStr = queryParam.toString();

        return produceRefinedString(queryString, replaceStr);
    }

    /**
     * Function to replace the placeholders in the MySQL query string with appropriate values, when the type of the queryParam
     * is "collection of a primitive type".
     *
     * @param paramType   Value of the XML attribute 'paramType', which also represents the type of the queryType parameter.
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param queryParam  Stores the required values to replace the placeholders in the queryString argument.
     * @return Returns the MySQL query-string after replacing the placeholders with appropriate values.
     */
    private <T> String handleCollectionOfPrimitives(String paramType, String queryString, T queryParam) {
        StringBuilder replaceStr = new StringBuilder();
        /*Checking whether the paramType is of a String[].*/
        boolean flag = paramType.equals("[Ljava.lang.String;");

        replaceStr.append("(");
        for (int i = 0; i < Array.getLength(queryParam); i++) {
            if (i == 0)
                replaceStr.append((flag) ? "'" : "").append(Array.get(queryParam, i).toString()).append((flag) ? "'" : "");
            else
                replaceStr.append(",").append((flag) ? "'" : "").append(Array.get(queryParam, i).toString()).append((flag) ? "'" : "");
        }
        replaceStr.append(")");
        return produceRefinedString(queryString, replaceStr.toString());
    }

    /**
     * Function to replace the placeholders in the MySQL query string with appropriate values, when the type of the queryParam
     * is an ArrayList.
     *
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param queryParam  Stores the required values to replace the placeholders in the queryString argument.
     * @return Returns the MySQL query-string after replacing the placeholders with appropriate values.
     */
    private <T> String handleArrayList(String queryString, T queryParam) {
        ArrayList<?> arr = (ArrayList<?>) queryParam;
        StringBuilder replaceStr = new StringBuilder();
        boolean isFirstElement = true;
        replaceStr.append("(");
        for (Object o : arr) {
            boolean flag = o.getClass().toString().equals("class java.lang.String");
            if (isFirstElement) {
                replaceStr.append((flag) ? "'" : "").append(o).append((flag) ? "'" : "");
                isFirstElement = false;
            } else
                replaceStr.append(",").append((flag) ? "'" : "").append(o).append((flag) ? "'" : "");
        }
        replaceStr.append(")");
        return produceRefinedString(queryString, replaceStr.toString());
    }

    /**
     * Function to replace the placeholders in the MySQL query string with appropriate values, when the type of the queryParam
     * is an object of a class, whose data members contain the relevant values for the placeholders.
     *
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param queryParam  Stores the required values to replace the placeholders in the queryString argument.
     * @return Returns the MySQL query-string after replacing the placeholders with appropriate values.
     */
    private <T> String handleObjects(String queryString, T queryParam) throws NoSuchFieldException, IllegalAccessException {
        StringBuilder refinedString = new StringBuilder();
        while (true) {
            int startIndex = queryString.indexOf("${");
            if (startIndex != -1) {
                int endIndex = queryString.indexOf("}");
                String dataMemberString = queryString.substring(startIndex + 2, endIndex).trim();
                /* Find the value of this data member and replace in the query string */
                Field field = queryParam.getClass().getDeclaredField(dataMemberString);
                field.setAccessible(true);
                String value = field.get(queryParam).toString();
                if(field.getType().toString().equals("class java.lang.String"))
                    refinedString.append(queryString, 0, startIndex).append("'").append(value).append("'");
                else
                    refinedString.append(queryString, 0, startIndex).append(value);
                queryString = queryString.substring(endIndex + 1);
            } else {
                refinedString.append(queryString);
                break;
            }
        }
        return refinedString.toString();
    }

    /**
     * This function is responsible for calling different handler functions by determining the right case.
     *
     * @param paramType   Value of the XML attribute 'paramType', which also represents the type of the queryType parameter.
     * @param queryString Stores the MySQL query-string extracted from the XML file.
     * @param queryParam  Stores the required values to replace the placeholders in the queryString argument.
     * @return Returns the MySQL query-string after replacing the placeholders with appropriate values.
     */
    private <T> String interpolateValuesInQuery(String paramType, String queryString, T queryParam) throws NoSuchFieldException, IllegalAccessException {
        if (isPrimitive(paramType)) {
            return handlePrimitives(paramType, queryString, queryParam);
        } else if (isCollectionOfPrimitives(paramType)) {
            return handleCollectionOfPrimitives(paramType, queryString, queryParam);
        } else if (paramType.equals("java.util.ArrayList")) {
            return handleArrayList(queryString, queryParam);
        } else {
            return handleObjects(queryString, queryParam);
        }
    }

    /**
     * This function serves to run the selectOne() and the selectMany() functions of the API.
     *
     * @param queryId    Unique ID of the query in the queries.xml file.
     * @param queryParam Parameter(s) to be used in the query.
     * @param resultType Type of the object that will be returned after
     *                   populating it with the data returned by the SQL.
     * @return A list of objects populated with the SQL results.
     */
    private <T, R> List<R> selectExecutor(String queryId, T queryParam, Class<R> resultType) throws XPathExpressionException, SQLException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException {
        List<String> parsedXML = xmlParser(queryId);

        if (parsedXML != null) {
            List<R> finalResult = new ArrayList<>();
            String paramType = parsedXML.get(0);
            String queryString = parsedXML.get(1);
            /*Validate whether the paramType matches with class type of queryParam*/
            String queryParamClsFQN = (queryParam != null) ? queryParam.getClass().getName() : "";

            if (paramType.equals(queryParamClsFQN)) {
                Statement statement = connection.createStatement();

                String refinedQueryString = interpolateValuesInQuery(paramType, queryString, queryParam);

                ResultSet resultSet = statement.executeQuery(refinedQueryString);
                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();

                /*Iterating over the records obtained as output*/
                while (resultSet.next()) {
                    R objectR = resultType.getConstructor().newInstance();
                    /*Iterating over the columns of a record*/
                    for (int i = 1; i <= resultSetMetaData.getColumnCount(); i++) {
                        /*Populating the POJOs with the output of the sql query*/
                        String columnHeaderString = resultSetMetaData.getColumnLabel(i);
                        Field field = objectR.getClass().getDeclaredField(columnHeaderString);
                        field.setAccessible(true);
                        String fieldType = field.getType().toString();
                        switch (fieldType) {
                            case "byte", "short", "int", "long", "float", "double", "boolean", "char"  -> field.set(objectR, resultSet.getObject(i));
                            default -> field.set(objectR, resultSet.getString(i));
                        }
                    }
                    finalResult.add(objectR);
                }
                return finalResult;
            } else {
                throw new RuntimeException("The type of queryParam does not match with the value of the paramType attribute.");
            }
        } else {
            throw new RuntimeException("The queryId does not match with the ids of any of the SQL queries.");
        }
    }

    /**
     * This function serves to run the insert(), the update(), and the delete() functions of the API.
     *
     * @param queryId    Unique ID of the query in the queries.xml file.
     * @param queryParam Parameter(s) to be used in the query.
     * @return The number of inserted/updated/deleted rows as a result of the query.
     */
    private <T> int insertDeleteUpdateExecutor(String queryId, T queryParam) throws XPathExpressionException, NoSuchFieldException, IllegalAccessException, SQLException {
        List<String> parsedXML = xmlParser(queryId);
        if (parsedXML != null) {
            String paramType = parsedXML.get(0);
            String queryString = parsedXML.get(1);

            /*Validate whether the paramType matches with class type of queryParam*/
            String queryParamClsFQN = (queryParam != null) ? queryParam.getClass().getName() : "";
            if (paramType.equals(queryParamClsFQN)) {
                Statement statement = connection.createStatement();
                String refinedQueryString = interpolateValuesInQuery(paramType, queryString, queryParam);
                return statement.executeUpdate(refinedQueryString);
            } else {
                throw new RuntimeException("The type of queryParam does not match with the value of the paramType attribute.");
            }
        } else {
            throw new RuntimeException("The queryId does not match with the ids of any of the SQL queries.");
        }
    }

    @Override
    public <T, R> R selectOne(String queryId, T queryParam, Class<R> resultType) throws SQLException, XPathExpressionException, NoSuchFieldException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, InstantiationException {
        List<R> executorOutputList = selectExecutor(queryId, queryParam, resultType);
        if (executorOutputList.size() == 0) {
            return null;
        } else if (executorOutputList.size() == 1) {
            return executorOutputList.get(0);
        } else {
            throw new RuntimeException("More than expected number of records is given as output by the MySQL query.");
        }
    }

    @Override
    public <T, R> List<R> selectMany(String queryId, T queryParam, Class<R> resultItemType) throws SQLException, XPathExpressionException, NoSuchFieldException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, InstantiationException {
        return selectExecutor(queryId, queryParam, resultItemType);
    }

    @Override
    public <T> int update(String queryId, T queryParam) throws SQLException, XPathExpressionException, NoSuchFieldException, IllegalAccessException {
        return insertDeleteUpdateExecutor(queryId, queryParam);
    }

    @Override
    public <T> int insert(String queryId, T queryParam) throws SQLException, XPathExpressionException, NoSuchFieldException, IllegalAccessException {
        return insertDeleteUpdateExecutor(queryId, queryParam);
    }

    @Override
    public <T> int delete(String queryId, T queryParam) throws SQLException, XPathExpressionException, NoSuchFieldException, IllegalAccessException {
        return insertDeleteUpdateExecutor(queryId, queryParam);
    }
}
